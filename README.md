# DesignPatterns
《大话设计模式》相关代码

一、六大设计原则
1、单一职责原则：就一个类而言，应该仅有一个引起它变化的原因。
2、开放-封闭原则：是说软件实体（类、模块、函数等）应该可以扩展，但是不可以修改；对于扩展是开放的，对于修改是封闭的。
3、依赖倒置原则：高层模块不应该依赖于低层模块，两个都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。
4、里氏替换原则：子类型必须能够替换掉它们的父类型。
5、迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；如果其中一个类需要调用另一个类的某一个方法时，可以通过第三者转发这个调用。“不和陌生人说话”
6、合成/聚合复用原则：尽量使用合成/聚合，尽量不要使用类继承。

二、设计模式
01、简单工厂模式
02、策略模式（Strategy）:
  它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
  策略模式是一种定义一系列算法的方法，从概念上来看，所有这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
  策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。
  策略模式就是用来封装算法的，在实践中，我们发现它可以用来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
03、装饰模式（Decorator）：
  动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比子类更为灵活。
  它把每个需要装饰的功能放在单独的类中，并让这个类包装它所需要的装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地，按顺序的使用装饰功能包装对象了。
04、代理模式（Proxy）：
  为其他对象提供一种代理以控制对这个对象的访问。
  代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。
05、工厂方法模式（Factory Method）:
  定义一个用于创建对象的接口，让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到子类。
  工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断转移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。
06、原型模式（Prototy）：
  用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
  原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。
07、模板方法模式：
  定义个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
  模板方法是通过把不变行为搬移到超类，去除子类中的重复代码来体现它的优势。
  模板方法模式就是提供了一个很好的代码复用平台。
  当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。
